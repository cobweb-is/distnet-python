import json
import random
import uuid
import os
import random

# Parameters
C_NUM_ROOTS  = 1
C_NUM_LEVELS = 3 #get_random_int(1, 5)
C_NUM_OF_WAYS = 2 #get_random_int(1, 6)
C_NUM_OF_CCT_BRANCHES = 0 # get_random_int(0, 2)

class ElectricalNetworkGenerator:
    def __init__(self, C_NUM_ROOTS, C_NUM_LEVELS, C_NUM_OF_WAYS):
        self.C_NUM_ROOTS = C_NUM_ROOTS
        self.C_NUM_LEVELS = C_NUM_LEVELS
        self.C_NUM_OF_WAYS = C_NUM_OF_WAYS
        self.node_id = 1
        self.boards = []
        self.circuits = []

    def generate_board(self, level, root_node_position, parent_phase=None, parent_id=None, parent_circuit_id=None, parent_circuit_type=None, is_q_cct_branch=None):
    # Determine the board phase
        child_board_id=""
        if self.node_id==1:
            parent_phase="3"
            parent_circuit_type = "TP"
        str_board_reference = str(f"Node: {self.node_id}")

        if parent_phase == "3":
            if parent_circuit_type == "TP":
                str_board_phase = "3"
            elif parent_circuit_type in ["RING", "RAD"]:
                str_board_phase = "1"
            else:
                str_board_phase = "unknown"  # Handle unexpected cases (optional)
        elif parent_phase == "1" and parent_circuit_type in ["RING", "RAD"]:
            str_board_phase = "1"
        else:
            str_board_phase = "unknown"  # Handle unexpected cases (optional)
        
        board = {
            "board_reference": str_board_reference,
            "board_id": str(uuid.uuid4()),  # Generate a unique UUID for the board_id
            "board_reference_type": "DB",
            "board_phase": str_board_phase,
            "board_location_block": random.choice(["A", "B", "C"]),
            "board_location_floor": random.choice(["1", "2", "3"]),
            "board_location": random.choice(["Room1", "Room2", "Room3"]),
            "board_supply_source_reference_id": parent_id,
            "building_id": "165b0674-f8f7-4278-9b65-0fa7387ca9c4",
            "board_comments": "Generated by script"
        }
        
        print("*")
        self.boards.append(board)
        if level < self.C_NUM_LEVELS:
            # Generate circuits for the board, we assume one board for each way
            for cct_index in range(C_NUM_OF_WAYS):
                arr_board_supply_source_reference_circuit_id = []
                if parent_phase == "3":
                    # force node 1 cct 1 to be TP always
                    if self.node_id==1:
                        circuit_type = "TP"
                    else:
                        circuit_type = random.choice(["RAD", "TP"])
                    lst_cct_phases = ["L1", "L2", "L3"]
                else:
                    circuit_type = random.choice(["RING", "RAD"])
                    lst_cct_phases = ["S"]

                # current_circuit_id= str(uuid.uuid4()).lower()
                
                for str_cct_phase in lst_cct_phases: # e.g loop thru the array L1,L2,L3
                    str_circuit_id = str(uuid.uuid4())  # Generate a unique UUID for the circuit_id
                    circuit = {
                        "circuit_id": str_circuit_id,
                        "board_id": board["board_id"],
                        "circuit_supplies_board_id" : "",
                        "circuit_reference": cct_index + 1,
                        "circuit_phase": str_cct_phase,
                        "circuit_is_3phase": circuit_type,
                        "circuit_equipment_connected": f"-<{board["board_reference"]} : {circuit_type}"
                    }
                    # Recursively generate child boards one per way
                    
                    #set downstream board phase
                    if parent_phase == "3":
                        if circuit_type == "TP":
                            str_board_phase = "3"
                        elif circuit_type in ["RING", "RAD"]:
                            str_board_phase = "1"
                        else:
                            str_board_phase = "unknown"  # Handle unexpected cases (optional)
                    elif parent_phase == "1" and circuit_type in ["RING", "RAD"]:
                        str_board_phase = "1"
                    else:
                        str_board_phase = "unknown"  # Handle unexpected cases (optional)

                    #if circuit type = TP only one tp child board is needed, but all three ccts will connect to it
                    # if not TP the get a board for each cct
                    if circuit_type == "TP":
                        print(f"TP  {str_cct_phase}")
                        if str_cct_phase == "L1":
                            self.node_id += 1
                            child_board_id = self.generate_board(level + 1, cct_index + 1, str_board_phase, board["board_id"], parent_id, circuit["circuit_is_3phase"])
                            if child_board_id is None:
                                print("Warning: generate_board returned None.")
                    else:
                        print(f"SP {str_cct_phase}")
                        print("--")
                        self.node_id += 1
                        child_board_id = self.generate_board(level + 1, cct_index + 1, str_board_phase, board["board_id"], parent_id, circuit["circuit_is_3phase"])
                        if child_board_id is None:
                            print("Warning: generate_board returned None.")
                    if level ==1:
                         #For level 1 ccts add additional branch boards for each way
                        for branch_index in range(C_NUM_OF_CCT_BRANCHES):
                            self.node_id += 1
                            child_board_id =self.generate_board(level + 1, cct_index + 1, str_board_phase, board["board_id"], parent_id,circuit["circuit_is_3phase"], "-B-")
                            print(child_board_id )
                    circuit["circuit_supplies_board_id"] = child_board_id
                    self.circuits.append(circuit)
        return board["board_id"]
        
       
    def get_random_int(min, max):
        rand = random.randint(min, max)
        return rand


    def generate_network(self):
        for i in range(self.C_NUM_ROOTS):
            self.generate_board(1, i + 1)
            #level, root_node_position, parent_phase, parent_id=None, parent_circuit_id=None, parent_circuit_type=None, is_q_cct_branch=None):

    def export_to_json(self, filename):
        data = {
            "building_id": "165b0674-f8f7-4278-9b65-0fa7387ca9c4",
            "tbl_board": self.boards,
            "tbl_circuit": self.circuits,
            "tbl_circuit_points_rcd": []
        }
        with open(filename, 'w') as outfile:
            json.dump(data, outfile, indent=4)

# Instantiate and generate the network
generator = ElectricalNetworkGenerator(C_NUM_ROOTS, C_NUM_LEVELS, C_NUM_OF_WAYS)
generator.generate_network()

# Export the data to a JSON file
# Specify the folder path
folder_path = r'C:\Users\micha\Dropbox\distnetwork\edisschematics\edisschematics\schematicapps\apps\distnet-react\src'
# Ensure the directory exists, if not, create it
os.makedirs(folder_path, exist_ok=True)
# Write JSON to a file in the specified folder
file_path = os.path.join(folder_path, 'network_data.json')
generator.export_to_json(file_path)
